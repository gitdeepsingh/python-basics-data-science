# -*- coding: utf-8 -*-
"""Lec_3_PFDS_2023.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YcLXVHgdXEZFMWBBWYH_tBbcRTbs-Hk9

# PFDS - Programming Fundamental for Data Science


## Course Instructor:

**Dr. Saurabh Das  (saurabh.das@iiti.ac.in)**

# Control Flow
Control statements allow you to do more complicated tasks.


# If statements:
"""

x = 3
y = 2
z = 1
if x == y:
    print("Hello")
elif x == z:
    print("Goodbye")
elif x == 3:
    print("x is 3")
else:
    print("???")

if 1 == 2:
    print("this runs")
print("this runs too")



"""#**For loops**

"""

print("loop 1")
for i in range(5): # default - start at 0, increment by 1
    print(i)

print("\nloop 2")
for i in range(10, 2, -2): # inputs are start, stop, step
    print(i)

"""#**while loops**"""

i = 1
while i < 100:
    print(i**2)
    i += i**2  # a += b is short for a = a + b

"""**continue** - skip the rest of a loop

**break** - exit from the loop
"""

for num in range(2, 10):
    if num % 2 == 0:
        continue # this jumps us back to the top
    print(f"Found {num}, an odd number")

n = 64
for x in range(2, n):
    if n % x == 0: # if n divisible by x
        print(f'{n} equals {x} * {n // x}')
        break

i=0

for i in range(5):
    for j in range(5*i):
        print(i,j,end='')
        if j == 10:
          #  print(i)
            print(j)
            break
    #break exits to here

"""**pass** does nothing"""

if False:
   pass #do nothing
else:
    print('True!')

"""# Exceptions"""

try:
    x = 100 / 0
except ZeroDivisionError:
    print("We divided by zero")

"""# Practise (10 min)
Print every power of 2 less than 10,000
"""

# Wrong solution
n=0
i=0
while i<= 10000:
  n +=1
  i=2**n
  print(n,2**n)

n=0
i=0
while i<= 10000:
  n +=1
  i=2**n
  if i<=10000:
    print(n,2**n)

"""# Functions

- Functions are used to abstract components of a program.
- Much like a mathematical function, they take some input and then do
something to find the result.
- Functions are declared with the keyword `def`
---


Start a function definition with the keyword def, Then comes the function name, with arguments in braces, and then a colon


> **def func(arg1, arg2):**


Use return to specify the output

---



"""

# def tells python you're trying to declare a function
def triangle_area(base, height):
    #here are operations
    #part of function
    #etc
    return 0.5 * base * height

triangle_area(1, 2)

triangle_area(-1, 2)

def triangle_area(base, height):
    if base < 0 or height < 0:
        raise ValueError("Base and height must be non-negative")
    return 0.5 * base * height

triangle_area(-1, 2)

def simple(a,b):
    return a,b

simple(1,2)

## What this function do?
def loop():
  for x in range(10):
    print(x)
    if x == 3:
       return x

loop()

"""# Try :
1. Write a function that prints ‘Hello, world!’
2. Write a function that returns ‘Hello, name!’, where name is a variable
"""

def hello_world():
    print('Hello, world!')

def hello_name(name):
# string formatting: more on this later.
    return 'Hello, {}!'.format(name)

hello_name('earth')





"""## Everything in python is an object, and can be passed into a function

"""

def f(x):
    return x+2

def twice(f,x):
    return f(f(x))

twice(f,2) # + 4

def simple(a):
    return (a,a+1,a+2,a+3)

a,b,c,d = simple(1)
print(a)
print(b)
print(c)
print(d)

"""# Recursive Function

It is even possible for the function to call itself.
"""

def factorial(x):
    """This is a recursive function
    to find the factorial of an integer"""

    if x == 1:
        return 1
    else:
        return (x * factorial(x-1))


num = 4
print("The factorial of", num, "is", factorial(num))

"""# Scope - Local and Global Variable
- Variables defined within a function (local), are only accessible within the
function.
- We could (but should not) change global variables within a function
"""

x = 1
def add_one(x):
  x = x + 1 # local x
  return x
y = add_one(x)
print(x,y)
# x = 1, y = 2

x = 0
def incr_x():
    x = x + 1 # does not work
    print(x)
def incr_x2():
    global x
    x = x + 1 # does work
    print(x)

incr_x()

"""# Dummy Variable in iteration"""

def n_apply(f, x, n):
    """applies f to x n times"""
    for _ in range(n):  # _ is dummy variable in iteration
        x = f(x)
        print(x)
    return x

n_apply(f, 1, 5) # 1 + 2*5